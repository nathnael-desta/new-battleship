// Copyright (c) Jupyter Development Team.
// Distributed under the terms of the Modified BSD License.
"use strict";
var properties_1 = require("@phosphor/properties");
var codeeditor_1 = require("../codeeditor");
var instancetracker_1 = require("../common/instancetracker");
var console_1 = require("../console");
var docregistry_1 = require("../docregistry");
var filebrowser_1 = require("../filebrowser");
var instancerestorer_1 = require("../instancerestorer");
var _1 = require("./");
/**
 * The class name for all main area portrait tab icons.
 */
var PORTRAIT_ICON_CLASS = 'jp-MainAreaPortraitIcon';
/**
 * The class name for the text editor icon from the default theme.
 */
var EDITOR_ICON_CLASS = 'jp-ImageTextEditor';
/**
 * The name of the factory that creates editor widgets.
 */
var FACTORY = 'Editor';
/**
 * The editor handler extension.
 */
var plugin = {
    activate: activate,
    id: 'jupyter.services.editor-handler',
    requires: [docregistry_1.IDocumentRegistry, instancerestorer_1.IInstanceRestorer, codeeditor_1.IEditorServices],
    provides: _1.IEditorTracker,
    autoStart: true
};
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Export the plugin as default.
 */
exports.default = plugin;
/**
 * Sets up the editor widget
 */
function activate(app, registry, restorer, editorServices) {
    var factory = new _1.EditorWidgetFactory({
        editorServices: editorServices,
        factoryOptions: {
            name: FACTORY,
            fileExtensions: ['*'],
            defaultFor: ['*']
        }
    });
    var tracker = new instancetracker_1.InstanceTracker({ namespace: 'editor' });
    // Handle state restoration.
    restorer.restore(tracker, {
        command: filebrowser_1.CommandIDs.open,
        args: function (widget) { return ({ path: widget.context.path, factory: FACTORY }); },
        name: function (widget) { return widget.context.path; }
    });
    factory.widgetCreated.connect(function (sender, widget) {
        widget.title.icon = PORTRAIT_ICON_CLASS + " " + EDITOR_ICON_CLASS;
        // Notify the instance tracker if restore data needs to update.
        widget.context.pathChanged.connect(function () { tracker.save(widget); });
        tracker.add(widget);
    });
    registry.addWidgetFactory(factory);
    var commands = app.commands, shell = app.shell;
    /**
     * Toggle editor line numbers
     */
    function toggleLineNums(args) {
        var widget = tracker.currentWidget;
        if (!widget) {
            return;
        }
        widget.editor.lineNumbers = !widget.editor.lineNumbers;
        if ((args && args['activate']) !== false) {
            shell.activateMain(widget.id);
        }
    }
    /**
     * Toggle editor line wrap
     */
    function toggleLineWrap(args) {
        var widget = tracker.currentWidget;
        if (!widget) {
            return;
        }
        widget.editor.wordWrap = !widget.editor.wordWrap;
        if ((args && args['activate']) !== false) {
            shell.activateMain(widget.id);
        }
    }
    /**
     * An attached property for the session id associated with an editor widget.
     */
    var sessionIdProperty = new properties_1.AttachedProperty({
        name: 'sessionId',
        create: function () { return ''; }
    });
    commands.addCommand(_1.CommandIDs.lineNumbers, {
        execute: function (args) { toggleLineNums(args); },
        label: 'Toggle Line Numbers'
    });
    commands.addCommand(_1.CommandIDs.lineWrap, {
        execute: function (args) { toggleLineWrap(args); },
        label: 'Toggle Line Wrap'
    });
    commands.addCommand(_1.CommandIDs.createConsole, {
        execute: function (args) {
            var widget = tracker.currentWidget;
            if (!widget) {
                return;
            }
            var options = {
                path: widget.context.path,
                preferredLanguage: widget.context.model.defaultKernelLanguage,
                activate: args['activate']
            };
            return commands.execute(console_1.CommandIDs.create, options)
                .then(function (id) { sessionIdProperty.set(widget, id); });
        },
        label: 'Create Console for Editor'
    });
    commands.addCommand(_1.CommandIDs.runCode, {
        execute: function (args) {
            var widget = tracker.currentWidget;
            if (!widget) {
                return;
            }
            // Get the session id.
            var id = sessionIdProperty.get(widget);
            if (!id) {
                return;
            }
            // Get the selected code from the editor.
            var editor = widget.editor;
            var selection = editor.getSelection();
            var start = editor.getOffsetAt(selection.start);
            var end = editor.getOffsetAt(selection.end);
            var options = {
                id: id,
                code: editor.model.value.text.substring(start, end),
                activate: args['activate']
            };
            return commands.execute(console_1.CommandIDs.inject, options);
        },
        label: 'Run Code'
    });
    return tracker;
}
//# sourceMappingURL=plugin.js.map