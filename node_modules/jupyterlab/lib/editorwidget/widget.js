// Copyright (c) Jupyter Development Team.
// Distributed under the terms of the Modified BSD License.
"use strict";
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var application_1 = require("@phosphor/application");
var docregistry_1 = require("../docregistry");
var widget_1 = require("../codeeditor/widget");
/**
 * The class name added to a dirty widget.
 */
var DIRTY_CLASS = 'jp-mod-dirty';
/**
 * The class name added to a jupyter code mirror widget.
 */
var EDITOR_CLASS = 'jp-EditorWidget';
/* tslint:disable */
/**
 * The editor tracker token.
 */
exports.IEditorTracker = new application_1.Token('jupyter.services.editor-tracker');
/* tslint:enable */
/**
 * A document widget for editors.
 */
var EditorWidget = (function (_super) {
    __extends(EditorWidget, _super);
    /**
     * Construct a new editor widget.
     */
    function EditorWidget(options) {
        var _this = _super.call(this, {
            factory: options.factory,
            model: options.context.model
        }) || this;
        _this.addClass(EDITOR_CLASS);
        var context = _this._context = options.context;
        _this._mimeTypeService = options.mimeTypeService;
        _this.editor.model.value.text = context.model.toString();
        _this._onPathChanged();
        context.pathChanged.connect(_this._onPathChanged, _this);
        context.ready.then(function () {
            _this._onContextReady();
        });
        return _this;
    }
    Object.defineProperty(EditorWidget.prototype, "context", {
        /**
         * Get the context for the editor widget.
         */
        get: function () {
            return this._context;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Handle actions that should be taken when the context is ready.
     */
    EditorWidget.prototype._onContextReady = function () {
        if (this.isDisposed) {
            return;
        }
        var model = this._context.model;
        var editor = this.editor;
        var value = editor.model.value;
        value.text = model.toString();
        // Prevent the initial loading from disk from being in the editor history.
        editor.clearHistory();
        this._handleDirtyState();
        model.stateChanged.connect(this._onModelStateChanged, this);
        model.contentChanged.connect(this._onContentChanged, this);
    };
    /**
     * Handle a change to the model state.
     */
    EditorWidget.prototype._onModelStateChanged = function (sender, args) {
        if (args.name === 'dirty') {
            this._handleDirtyState();
        }
    };
    /**
     * Handle the dirty state of the model.
     */
    EditorWidget.prototype._handleDirtyState = function () {
        if (this._context.model.dirty) {
            this.title.className += " " + DIRTY_CLASS;
        }
        else {
            this.title.className = this.title.className.replace(DIRTY_CLASS, '');
        }
    };
    /**
     * Handle a change in model content.
     */
    EditorWidget.prototype._onContentChanged = function () {
        var value = this.editor.model.value;
        var old = value.text;
        var text = this._context.model.toString();
        if (old !== text) {
            value.text = text;
        }
    };
    /**
     * Handle a change to the path.
     */
    EditorWidget.prototype._onPathChanged = function () {
        var editor = this.editor;
        var path = this._context.path;
        editor.model.mimeType = this._mimeTypeService.getMimeTypeByFilePath(path);
        this.title.label = path.split('/').pop();
    };
    return EditorWidget;
}(widget_1.CodeEditorWidget));
exports.EditorWidget = EditorWidget;
/**
 * A widget factory for editors.
 */
var EditorWidgetFactory = (function (_super) {
    __extends(EditorWidgetFactory, _super);
    /**
     * Construct a new editor widget factory.
     */
    function EditorWidgetFactory(options) {
        var _this = _super.call(this, options.factoryOptions) || this;
        _this._services = options.editorServices;
        return _this;
    }
    /**
     * Create a new widget given a context.
     */
    EditorWidgetFactory.prototype.createNewWidget = function (context) {
        var func = this._services.factoryService.newDocumentEditor.bind(this._services.factoryService);
        var factory = function (options) {
            options.lineNumbers = true;
            options.readOnly = false;
            options.wordWrap = true;
            return func(options);
        };
        return new EditorWidget({
            factory: factory,
            context: context,
            mimeTypeService: this._services.mimeTypeService
        });
    };
    return EditorWidgetFactory;
}(docregistry_1.ABCWidgetFactory));
exports.EditorWidgetFactory = EditorWidgetFactory;
//# sourceMappingURL=widget.js.map