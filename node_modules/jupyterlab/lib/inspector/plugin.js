// Copyright (c) Jupyter Development Team.
// Distributed under the terms of the Modified BSD License.
"use strict";
var commandpalette_1 = require("../commandpalette");
var instancetracker_1 = require("../common/instancetracker");
var console_1 = require("../console");
var instancerestorer_1 = require("../instancerestorer");
var notebook_1 = require("../notebook");
var manager_1 = require("./manager");
var _1 = require("./");
/**
 * The inspector instance tracker.
 */
var tracker = new instancetracker_1.InstanceTracker({ namespace: 'inspector' });
/**
 * A service providing code introspection.
 */
var service = {
    id: 'jupyter.services.inspector',
    requires: [commandpalette_1.ICommandPalette, instancerestorer_1.IInstanceRestorer],
    provides: _1.IInspector,
    autoStart: true,
    activate: function (app, palette, restorer) {
        var manager = new manager_1.InspectorManager();
        var category = 'Inspector';
        var command = _1.CommandIDs.open;
        var label = 'Open Inspector';
        /**
         * Create and track a new inspector.
         */
        function newInspector() {
            var inspector = new _1.Inspector({ items: Private.defaultInspectorItems });
            inspector.id = 'jp-inspector';
            inspector.title.label = 'Inspector';
            inspector.title.closable = true;
            inspector.disposed.connect(function () {
                if (manager.inspector === inspector) {
                    manager.inspector = null;
                }
            });
            tracker.add(inspector);
            return inspector;
        }
        // Handle state restoration.
        restorer.restore(tracker, {
            command: command,
            args: function () { return null; },
            name: function () { return 'inspector'; }
        });
        // Add command to registry and palette.
        app.commands.addCommand(command, {
            label: label,
            execute: function () {
                if (!manager.inspector || manager.inspector.isDisposed) {
                    manager.inspector = newInspector();
                    app.shell.addToMainArea(manager.inspector);
                }
                if (manager.inspector.isAttached) {
                    app.shell.activateMain(manager.inspector.id);
                }
            }
        });
        palette.addItem({ command: command, category: category });
        return manager;
    }
};
/**
 * An extension that registers consoles for inspection.
 */
var consolePlugin = {
    id: 'jupyter.extensions.console-inspector',
    requires: [_1.IInspector, console_1.IConsoleTracker],
    autoStart: true,
    activate: function (app, manager, consoles) {
        // Maintain association of new consoles with their respective handlers.
        var handlers = {};
        // Create a handler for each console that is created.
        consoles.widgetAdded.connect(function (sender, parent) {
            var session = parent.console.session;
            var kernel = session.kernel;
            var rendermime = parent.console.rendermime;
            var handler = new _1.InspectionHandler({ kernel: kernel, rendermime: rendermime });
            // Associate the handler to the widget.
            handlers[parent.id] = handler;
            // Set the initial editor.
            var cell = parent.console.prompt;
            handler.editor = cell && cell.editor;
            // Listen for prompt creation.
            parent.console.promptCreated.connect(function (sender, cell) {
                handler.editor = cell && cell.editor;
            });
            // Listen for kernel changes.
            session.kernelChanged.connect(function (sender, kernel) {
                handler.kernel = kernel;
            });
            // Listen for parent disposal.
            parent.disposed.connect(function () {
                delete handlers[parent.id];
                handler.dispose();
            });
        });
        // Keep track of console instances and set inspector source.
        app.shell.currentChanged.connect(function (sender, args) {
            var widget = args.newValue;
            if (!widget || !consoles.has(widget)) {
                return;
            }
            var source = handlers[widget.id];
            if (source) {
                manager.source = source;
            }
        });
    }
};
/**
 * An extension that registers notebooks for inspection.
 */
var notebookPlugin = {
    id: 'jupyter.extensions.notebook-inspector',
    requires: [_1.IInspector, notebook_1.INotebookTracker],
    autoStart: true,
    activate: function (app, manager, notebooks) {
        // Maintain association of new notebooks with their respective handlers.
        var handlers = {};
        // Create a handler for each notebook that is created.
        notebooks.widgetAdded.connect(function (sender, parent) {
            var kernel = parent.kernel;
            var rendermime = parent.rendermime;
            var handler = new _1.InspectionHandler({ kernel: kernel, rendermime: rendermime });
            // Associate the handler to the widget.
            handlers[parent.id] = handler;
            // Set the initial editor.
            var cell = parent.notebook.activeCell;
            handler.editor = cell && cell.editor;
            // Listen for active cell changes.
            parent.notebook.activeCellChanged.connect(function (sender, cell) {
                handler.editor = cell && cell.editor;
            });
            // Listen for kernel changes.
            parent.kernelChanged.connect(function (sender, kernel) {
                handler.kernel = kernel;
            });
            // Listen for parent disposal.
            parent.disposed.connect(function () {
                delete handlers[parent.id];
                handler.dispose();
            });
        });
        // Keep track of notebook instances and set inspector source.
        app.shell.currentChanged.connect(function (sender, args) {
            var widget = args.newValue;
            if (!widget || !notebooks.has(widget)) {
                return;
            }
            var source = handlers[widget.id];
            if (source) {
                manager.source = source;
            }
        });
    }
};
/**
 * Export the plugins as default.
 */
var plugins = [
    service, consolePlugin, notebookPlugin
];
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = plugins;
/**
 * A namespace for private data.
 */
var Private;
(function (Private) {
    /**
     * The default set of inspector items added to the inspector panel.
     */
    Private.defaultInspectorItems = [
        {
            className: 'jp-HintsInspectorItem',
            name: 'Hints',
            rank: 20,
            type: 'hints'
        }
    ];
})(Private || (Private = {}));
//# sourceMappingURL=plugin.js.map