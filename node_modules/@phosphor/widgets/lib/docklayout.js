"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
/*-----------------------------------------------------------------------------
| Copyright (c) 2014-2017, PhosphorJS Contributors
|
| Distributed under the terms of the BSD 3-Clause License.
|
| The full license is in the file LICENSE, distributed with this software.
|----------------------------------------------------------------------------*/
var algorithm_1 = require("@phosphor/algorithm");
var domutils_1 = require("@phosphor/domutils");
var messaging_1 = require("@phosphor/messaging");
var boxengine_1 = require("./boxengine");
var layout_1 = require("./layout");
var widget_1 = require("./widget");
/**
 * A layout which provides a flexible docking arrangement.
 *
 * #### Notes
 * The layout handles the `currentChanged` signals of the tab bars and
 * the corresponding visibility of the child widgets. The widget which
 * consumes the layout is responsible for all other tab interactions
 * as well as all mouse and drag events.
 */
var DockLayout = (function (_super) {
    __extends(DockLayout, _super);
    /**
     * Construct a new dock layout.
     *
     * @param options - The options for initializing the layout.
     */
    function DockLayout(options) {
        var _this = _super.call(this) || this;
        _this._dirty = false;
        _this._root = null;
        _this._box = null;
        _this.renderer = options.renderer;
        _this._spacing = Private.clampSpacing(options.spacing);
        return _this;
    }
    /**
     * Dispose of the resources held by the layout.
     *
     * #### Notes
     * This will clear and dispose all widgets in the layout.
     */
    DockLayout.prototype.dispose = function () {
        // Get an iterator over the widgets in the layout.
        var widgets = this.iter();
        // Clear the layout before disposing the widgets.
        this._box = null;
        this._root = null;
        // Dispose of the widgets contained in the old layout root.
        algorithm_1.each(widgets, function (widget) { widget.dispose(); });
        // Dispose of the base class.
        _super.prototype.dispose.call(this);
    };
    Object.defineProperty(DockLayout.prototype, "spacing", {
        /**
         * Get the inter-element spacing for the dock layout.
         */
        get: function () {
            return this._spacing;
        },
        /**
         * Set the inter-element spacing for the dock layout.
         */
        set: function (value) {
            value = Private.clampSpacing(value);
            if (this._spacing === value) {
                return;
            }
            this._spacing = value;
            if (!this.parent) {
                return;
            }
            this.parent.fit();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DockLayout.prototype, "isEmpty", {
        /**
         * Whether the dock layout is empty.
         */
        get: function () {
            return this._root === null;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Create an iterator over all widgets in the layout.
     *
     * @returns A new iterator over the widgets in the layout.
     *
     * #### Notes
     * This iterator includes the generated tab bars.
     */
    DockLayout.prototype.iter = function () {
        return this._root ? Private.iterAllWidgets(this._root) : algorithm_1.empty();
    };
    /**
     * Create an iterator over the user widgets in the layout.
     *
     * @returns A new iterator over the user widgets in the layout.
     *
     * #### Notes
     * This iterator does not include the generated tab bars.
     */
    DockLayout.prototype.widgets = function () {
        return this._root ? Private.iterUserWidgets(this._root) : algorithm_1.empty();
    };
    /**
     * Create an iterator over the tab bars in the layout.
     *
     * @returns A new iterator over the tab bars in the layout.
     *
     * #### Notes
     * This iterator does not include the user widgets.
     */
    DockLayout.prototype.tabBars = function () {
        return this._root ? Private.iterTabBars(this._root) : algorithm_1.empty();
    };
    /**
     * Create an iterator over the handles in the layout.
     *
     * @returns A new iterator over the handles in the layout.
     */
    DockLayout.prototype.handles = function () {
        return this._root ? Private.iterHandles(this._root) : algorithm_1.empty();
    };
    /**
     * Move a handle to the given offset position.
     *
     * @param handle - The handle to move.
     *
     * @param offsetX - The desired offset X position of the handle.
     *
     * @param offsetY - The desired offset Y position of the handle.
     *
     * #### Notes
     * If the given handle is not contained in the layout, this is no-op.
     *
     * The handle will be moved as close as possible to the desired
     * position without violating any of the layout constraints.
     *
     * Only one of the coordinates is used depending on the orientation
     * of the handle. This method accepts both coordinates to make it
     * easy to invoke from a mouse move event without needing to know
     * the handle orientation.
     */
    DockLayout.prototype.moveHandle = function (handle, offsetX, offsetY) {
        // Bail early if there is no root or if the handle is hidden.
        if (!this._root || handle.classList.contains('p-mod-hidden')) {
            return;
        }
        // Lookup the split node for the handle.
        var data = Private.findSplitNode(this._root, handle);
        if (!data) {
            return;
        }
        // Compute the desired delta movement for the handle.
        var delta;
        if (data.node.orientation === 'horizontal') {
            delta = offsetX - handle.offsetLeft;
        }
        else {
            delta = offsetY - handle.offsetTop;
        }
        // Bail if there is no handle movement.
        if (delta === 0) {
            return;
        }
        // Prevent sibling resizing unless needed.
        Private.holdSizes(data.node.sizers);
        // Adjust the sizers to reflect the handle movement.
        boxengine_1.BoxEngine.adjust(data.node.sizers, data.index, delta);
        // Update the layout of the widgets.
        if (this.parent) {
            this.parent.update();
        }
    };
    /**
     * Save the current configuration of the dock layout.
     *
     * @returns A new snapshot of the current dock layout configuration.
     *
     * #### Notes
     * The return value can be provided to the `restoreLayout` method
     * in order to restore the layout to its current configuration.
     */
    DockLayout.prototype.saveLayout = function () {
        // Bail early if there is no root.
        if (!this._root) {
            return { main: null };
        }
        // Hold the current layout sizes.
        Private.holdLayoutSizes(this._root);
        // Create the main area config.
        var main = Private.createAreaConfig(this._root);
        // Return the layout config.
        return { main: main };
    };
    /**
     * Restore the layout to a previously saved configuration.
     *
     * @param config - The layout configuration to restore.
     *
     * @throws An error if the config is invalid.
     *
     * #### Notes
     * Widgets which currently belong to the layout but which are not
     * contained in the config will be unparented.
     */
    DockLayout.prototype.restoreLayout = function (config) {
        var _this = this;
        // Validate the config and collect the contained widgets.
        var widgetSet = Private.validateLayoutConfig(config);
        // Create iterators over the old widgets and tab bars.
        var oldWidgets = this.widgets();
        var oldTabBars = this.tabBars();
        // Clear the root before removing the old widgets.
        this._root = null;
        // Unparent the old widgets which are not in the new config.
        algorithm_1.each(oldWidgets, function (widget) {
            if (!widgetSet.has(widget)) {
                widget.parent = null;
            }
        });
        // Dispose of the old tab bars.
        algorithm_1.each(oldTabBars, function (tabBar) {
            tabBar.dispose();
        });
        // Reparent the new widgets to the current parent.
        widgetSet.forEach(function (widget) {
            widget.parent = _this.parent;
        });
        // Create the root node for the new config.
        if (config.main) {
            this._root = Private.realizeAreaConfig(config.main, {
                createTabBar: function () { return _this._createTabBar(); },
                createHandle: function () { return _this._createHandle(); }
            });
        }
        else {
            this._root = null;
        }
        // If there is no parent, there is nothing more to do.
        if (!this.parent) {
            return;
        }
        // Attach the new widgets to the parent.
        widgetSet.forEach(function (widget) {
            _this.attachWidget(widget);
        });
        // Post a fit request to the parent.
        this.parent.fit();
        // Flush the message loop on IE and Edge to prevent flicker.
        if (domutils_1.Platform.IS_EDGE || domutils_1.Platform.IS_IE) {
            messaging_1.MessageLoop.flush();
        }
    };
    /**
     * Add a widget to the dock layout.
     *
     * @param widget - The widget to add to the dock layout.
     *
     * @param options - The additional options for adding the widget.
     *
     * #### Notes
     * The widget will be moved if it is already contained in the layout.
     *
     * An error will be thrown if the reference widget is invalid.
     */
    DockLayout.prototype.addWidget = function (widget, options) {
        if (options === void 0) { options = {}; }
        // Parse the options.
        var ref = options.ref || null;
        var mode = options.mode || 'tab-after';
        // Find the tab node which holds the reference widget.
        var refNode = null;
        if (this._root && ref) {
            refNode = Private.findTabNode(this._root, ref);
        }
        // Throw an error if the reference widget is invalid.
        if (ref && !refNode) {
            throw new Error('Reference widget is not in the layout.');
        }
        // Reparent the widget to the current layout parent.
        widget.parent = this.parent;
        // Insert the widget according to the insert mode.
        switch (mode) {
            case 'tab-after':
                this._insertTab(widget, ref, refNode, true);
                break;
            case 'tab-before':
                this._insertTab(widget, ref, refNode, false);
                break;
            case 'split-top':
                this._insertSplit(widget, ref, refNode, 'vertical', false);
                break;
            case 'split-left':
                this._insertSplit(widget, ref, refNode, 'horizontal', false);
                break;
            case 'split-right':
                this._insertSplit(widget, ref, refNode, 'horizontal', true);
                break;
            case 'split-bottom':
                this._insertSplit(widget, ref, refNode, 'vertical', true);
                break;
        }
        // Do nothing else if there is no parent widget.
        if (!this.parent) {
            return;
        }
        // Ensure the widget is attached to the parent widget.
        this.attachWidget(widget);
        // Post a fit request for the parent widget.
        this.parent.fit();
    };
    /**
     * Remove a widget from the layout.
     *
     * @param widget - The widget to remove from the layout.
     *
     * #### Notes
     * A widget is automatically removed from the layout when its `parent`
     * is set to `null`. This method should only be invoked directly when
     * removing a widget from a layout which has yet to be installed on a
     * parent widget.
     *
     * This method does *not* modify the widget's `parent`.
     */
    DockLayout.prototype.removeWidget = function (widget) {
        // Remove the widget from its current layout location.
        this._removeWidget(widget);
        // Do nothing else if there is no parent widget.
        if (!this.parent) {
            return;
        }
        // Detach the widget from the parent widget.
        this.detachWidget(widget);
        // Post a fit request for the parent widget.
        this.parent.fit();
    };
    /**
     * Perform layout initialization which requires the parent widget.
     */
    DockLayout.prototype.init = function () {
        var _this = this;
        // Perform superclass initialization.
        _super.prototype.init.call(this);
        // Attach each widget to the parent.
        algorithm_1.each(this, function (widget) { _this.attachWidget(widget); });
        // Attach each handle to the parent.
        algorithm_1.each(this.handles(), function (handle) { _this.parent.node.appendChild(handle); });
        // Post a fit request for the parent widget.
        this.parent.fit();
    };
    /**
     * Attach the widget to the layout parent widget.
     *
     * @param widget - The widget to attach to the parent.
     *
     * #### Notes
     * This is a no-op if the widget is already attached.
     */
    DockLayout.prototype.attachWidget = function (widget) {
        // Do nothing if the widget is already attached.
        if (this.parent.node === widget.node.parentNode) {
            return;
        }
        // Prepare the layout geometry for the widget.
        widget_1.Widget.prepareGeometry(widget);
        // Send a `'before-attach'` message if the parent is attached.
        if (this.parent.isAttached) {
            messaging_1.MessageLoop.sendMessage(widget, widget_1.Widget.Msg.BeforeAttach);
        }
        // Add the widget's node to the parent.
        this.parent.node.appendChild(widget.node);
        // Send an `'after-attach'` message if the parent is attached.
        if (this.parent.isAttached) {
            messaging_1.MessageLoop.sendMessage(widget, widget_1.Widget.Msg.AfterAttach);
        }
    };
    /**
     * Detach the widget from the layout parent widget.
     *
     * @param widget - The widget to detach from the parent.
     *
     * #### Notes
     * This is a no-op if the widget is not attached.
     */
    DockLayout.prototype.detachWidget = function (widget) {
        // Do nothing if the widget is not attached.
        if (this.parent.node !== widget.node.parentNode) {
            return;
        }
        // Send a `'before-detach'` message if the parent is attached.
        if (this.parent.isAttached) {
            messaging_1.MessageLoop.sendMessage(widget, widget_1.Widget.Msg.BeforeDetach);
        }
        // Remove the widget's node from the parent.
        this.parent.node.removeChild(widget.node);
        // Send an `'after-detach'` message if the parent is attached.
        if (this.parent.isAttached) {
            messaging_1.MessageLoop.sendMessage(widget, widget_1.Widget.Msg.AfterDetach);
        }
        // Reset the layout geometry for the widget.
        widget_1.Widget.resetGeometry(widget);
    };
    /**
     * A message handler invoked on a `'before-show'` message.
     */
    DockLayout.prototype.onBeforeShow = function (msg) {
        _super.prototype.onBeforeShow.call(this, msg);
        this.parent.update();
    };
    /**
     * A message handler invoked on a `'before-attach'` message.
     */
    DockLayout.prototype.onBeforeAttach = function (msg) {
        _super.prototype.onBeforeAttach.call(this, msg);
        this.parent.fit();
    };
    /**
     * A message handler invoked on a `'child-shown'` message.
     */
    DockLayout.prototype.onChildShown = function (msg) {
        this.parent.fit();
    };
    /**
     * A message handler invoked on a `'child-hidden'` message.
     */
    DockLayout.prototype.onChildHidden = function (msg) {
        this.parent.fit();
    };
    /**
     * A message handler invoked on a `'resize'` message.
     */
    DockLayout.prototype.onResize = function (msg) {
        if (this.parent.isVisible) {
            this._update(msg.width, msg.height);
        }
    };
    /**
     * A message handler invoked on an `'update-request'` message.
     */
    DockLayout.prototype.onUpdateRequest = function (msg) {
        if (this.parent.isVisible) {
            this._update(-1, -1);
        }
    };
    /**
     * A message handler invoked on a `'fit-request'` message.
     */
    DockLayout.prototype.onFitRequest = function (msg) {
        if (this.parent.isAttached) {
            this._fit();
        }
    };
    /**
     * Remove the specified widget from the layout structure.
     *
     * #### Notes
     * This is a no-op if the widget is not in the layout tree.
     *
     * This does not detach the widget from the parent node.
     */
    DockLayout.prototype._removeWidget = function (widget) {
        // Bail early if there is no layout root.
        if (!this._root) {
            return;
        }
        // Find the tab node which contains the given widget.
        var tabNode = Private.findTabNode(this._root, widget);
        // Bail early if the tab node is not found.
        if (!tabNode) {
            return;
        }
        // If there are multiple tabs, just remove the widget's tab.
        if (tabNode.tabBar.titles.length > 1) {
            tabNode.tabBar.removeTab(widget.title);
            return;
        }
        // Otherwise, the tab node needs to be removed...
        // Dispose the tab bar.
        tabNode.tabBar.dispose();
        // Handle the case where the tab node is the root.
        if (this._root === tabNode) {
            this._root = null;
            return;
        }
        // Otherwise, remove the tab node from its parent...
        // Prevent widget resizing unless needed.
        Private.holdLayoutSizes(this._root);
        // Clear the parent reference on the tab node.
        var splitNode = tabNode.parent;
        tabNode.parent = null;
        // Remove the tab node from its parent split node.
        var i = algorithm_1.ArrayExt.removeFirstOf(splitNode.children, tabNode);
        var handle = algorithm_1.ArrayExt.removeAt(splitNode.handles, i);
        algorithm_1.ArrayExt.removeAt(splitNode.sizers, i);
        // Remove the handle from its parent DOM node.
        if (handle.parentNode) {
            handle.parentNode.removeChild(handle);
        }
        // If there are multiple children, just update the handles.
        if (splitNode.children.length > 1) {
            Private.syncHandles(splitNode);
            return;
        }
        // Otherwise, the split node also needs to be removed...
        // Clear the parent reference on the split node.
        var maybeParent = splitNode.parent;
        splitNode.parent = null;
        // Lookup the remaining child node and handle.
        var childNode = splitNode.children[0];
        var childHandle = splitNode.handles[0];
        // Clear the split node data.
        splitNode.children.length = 0;
        splitNode.handles.length = 0;
        splitNode.sizers.length = 0;
        // Remove the child handle from its parent node.
        if (childHandle.parentNode) {
            childHandle.parentNode.removeChild(childHandle);
        }
        // Handle the case where the split node is the root.
        if (this._root === splitNode) {
            childNode.parent = null;
            this._root = childNode;
            return;
        }
        // Otherwise, move the child node to the parent node...
        var parentNode = maybeParent;
        // Lookup the index of the split node.
        var j = parentNode.children.indexOf(splitNode);
        // Handle the case where the child node is a tab node.
        if (childNode instanceof Private.TabLayoutNode) {
            childNode.parent = parentNode;
            parentNode.children[j] = childNode;
            return;
        }
        // Remove the split data from the parent.
        var splitHandle = algorithm_1.ArrayExt.removeAt(parentNode.handles, j);
        algorithm_1.ArrayExt.removeAt(parentNode.children, j);
        algorithm_1.ArrayExt.removeAt(parentNode.sizers, j);
        // Remove the handle from its parent node.
        if (splitHandle.parentNode) {
            splitHandle.parentNode.removeChild(splitHandle);
        }
        // The child node and the split parent node will have the same
        // orientation. Merge the grand-children with the parent node.
        for (var i_1 = 0, n = childNode.children.length; i_1 < n; ++i_1) {
            var gChild = childNode.children[i_1];
            var gHandle = childNode.handles[i_1];
            var gSizer = childNode.sizers[i_1];
            algorithm_1.ArrayExt.insert(parentNode.children, j + i_1, gChild);
            algorithm_1.ArrayExt.insert(parentNode.handles, j + i_1, gHandle);
            algorithm_1.ArrayExt.insert(parentNode.sizers, j + i_1, gSizer);
            gChild.parent = parentNode;
        }
        // Clear the child node.
        childNode.children.length = 0;
        childNode.handles.length = 0;
        childNode.sizers.length = 0;
        childNode.parent = null;
        // Sync the handles on the parent node.
        Private.syncHandles(parentNode);
    };
    /**
     * Insert a widget next to an existing tab.
     *
     * #### Notes
     * This does not attach the widget to the parent widget.
     */
    DockLayout.prototype._insertTab = function (widget, ref, refNode, after) {
        // Do nothing if the tab is inserted next to itself.
        if (widget === ref) {
            return;
        }
        // Create the root if it does not exist.
        if (!this._root) {
            var tabNode = new Private.TabLayoutNode(this._createTabBar());
            tabNode.tabBar.addTab(widget.title);
            this._root = tabNode;
            return;
        }
        // Use the first tab node as the ref node if needed.
        if (!refNode) {
            refNode = Private.firstTabNode(this._root);
        }
        // If the widget is not contained in the ref node, ensure it is
        // removed from the layout and hidden before being added again.
        if (refNode.tabBar.titles.indexOf(widget.title) === -1) {
            this._removeWidget(widget);
            widget.hide();
        }
        // Lookup the target index for inserting the tab.
        var index;
        if (ref) {
            index = refNode.tabBar.titles.indexOf(ref.title);
        }
        else {
            index = refNode.tabBar.currentIndex;
        }
        // Insert the widget's tab relative to the target index.
        refNode.tabBar.insertTab(index + (after ? 1 : 0), widget.title);
    };
    /**
     * Insert a widget as a new split area.
     *
     * #### Notes
     * This does not attach the widget to the parent widget.
     */
    DockLayout.prototype._insertSplit = function (widget, ref, refNode, orientation, after) {
        // Do nothing if there is no effective split.
        if (widget === ref && refNode && refNode.tabBar.titles.length === 1) {
            return;
        }
        // Ensure the widget is removed from the current layout.
        this._removeWidget(widget);
        // Create the tab layout node to hold the widget.
        var tabNode = new Private.TabLayoutNode(this._createTabBar());
        tabNode.tabBar.addTab(widget.title);
        // Set the root if it does not exist.
        if (!this._root) {
            this._root = tabNode;
            return;
        }
        // If the ref node parent is null, split the root.
        if (!refNode || !refNode.parent) {
            // Ensure the root is split with the correct orientation.
            var root = this._splitRoot(orientation);
            // Determine the insert index for the new tab node.
            var i_2 = after ? root.children.length : 0;
            // Normalize the split node.
            Private.normalizeSizes(root);
            // Create the sizer for new tab node.
            var sizer = Private.createSizer(refNode ? 1 : Private.GOLDEN_RATIO);
            // Insert the tab node sized to the golden ratio.
            algorithm_1.ArrayExt.insert(root.children, i_2, tabNode);
            algorithm_1.ArrayExt.insert(root.sizers, i_2, sizer);
            algorithm_1.ArrayExt.insert(root.handles, i_2, this._createHandle());
            tabNode.parent = root;
            // Re-normalize the split node to maintain the ratios.
            Private.normalizeSizes(root);
            // Finally, synchronize the visibility of the handles.
            Private.syncHandles(root);
            return;
        }
        // Lookup the split node for the ref widget.
        var splitNode = refNode.parent;
        // If the split node already had the correct orientation,
        // the widget can be inserted into the split node directly.
        if (splitNode.orientation === orientation) {
            // Find the index of the ref node.
            var i_3 = splitNode.children.indexOf(refNode);
            // Normalize the split node.
            Private.normalizeSizes(splitNode);
            // Consume half the space for the insert location.
            var s = splitNode.sizers[i_3].sizeHint /= 2;
            // Insert the tab node sized to the other half.
            var j_1 = i_3 + (after ? 1 : 0);
            algorithm_1.ArrayExt.insert(splitNode.children, j_1, tabNode);
            algorithm_1.ArrayExt.insert(splitNode.sizers, j_1, Private.createSizer(s));
            algorithm_1.ArrayExt.insert(splitNode.handles, j_1, this._createHandle());
            tabNode.parent = splitNode;
            // Finally, synchronize the visibility of the handles.
            Private.syncHandles(splitNode);
            return;
        }
        // Remove the ref node from the split node.
        var i = algorithm_1.ArrayExt.removeFirstOf(splitNode.children, refNode);
        // Create a new normalized split node for the children.
        var childNode = new Private.SplitLayoutNode(orientation);
        childNode.normalized = true;
        // Add the ref node sized to half the space.
        childNode.children.push(refNode);
        childNode.sizers.push(Private.createSizer(0.5));
        childNode.handles.push(this._createHandle());
        refNode.parent = childNode;
        // Add the tab node sized to the other half.
        var j = after ? 1 : 0;
        algorithm_1.ArrayExt.insert(childNode.children, j, tabNode);
        algorithm_1.ArrayExt.insert(childNode.sizers, j, Private.createSizer(0.5));
        algorithm_1.ArrayExt.insert(childNode.handles, j, this._createHandle());
        tabNode.parent = childNode;
        // Synchronize the visibility of the handles.
        Private.syncHandles(childNode);
        // Finally, add the new child node to the original split node.
        algorithm_1.ArrayExt.insert(splitNode.children, i, childNode);
        childNode.parent = splitNode;
    };
    /**
     * Ensure the root is a split node with the given orientation.
     */
    DockLayout.prototype._splitRoot = function (orientation) {
        // Bail early if the root already meets the requirements.
        var oldRoot = this._root;
        if (oldRoot instanceof Private.SplitLayoutNode) {
            if (oldRoot.orientation === orientation) {
                return oldRoot;
            }
        }
        // Create a new root node with the specified orientation.
        var newRoot = this._root = new Private.SplitLayoutNode(orientation);
        // Add the old root to the new root.
        if (oldRoot) {
            newRoot.children.push(oldRoot);
            newRoot.sizers.push(Private.createSizer(0));
            newRoot.handles.push(this._createHandle());
            oldRoot.parent = newRoot;
        }
        // Return the new root as a convenience.
        return newRoot;
    };
    /**
     * Fit the layout to the total size required by the widgets.
     */
    DockLayout.prototype._fit = function () {
        // Set up the size limits.
        var minW = 0;
        var minH = 0;
        var maxW = Infinity;
        var maxH = Infinity;
        // Update the limits for the root layout node.
        if (this._root) {
            var limits = Private.fitLayoutNode(this._root, this._spacing);
            minW = limits.minWidth;
            minH = limits.minHeight;
            maxW = limits.maxWidth;
            maxH = limits.maxHeight;
        }
        // Update the box sizing and add it to the size limits.
        var box = this._box = domutils_1.ElementExt.boxSizing(this.parent.node);
        minW += box.horizontalSum;
        minH += box.verticalSum;
        maxW += box.horizontalSum;
        maxH += box.verticalSum;
        // Update the parent's size constraints.
        var style = this.parent.node.style;
        style.minWidth = minW + "px";
        style.minHeight = minH + "px";
        style.maxWidth = maxW === Infinity ? 'none' : maxW + "px";
        style.maxHeight = maxH === Infinity ? 'none' : maxH + "px";
        // Set the dirty flag to ensure only a single update occurs.
        this._dirty = true;
        // Notify the ancestor that it should fit immediately. This may
        // cause a resize of the parent, fulfilling the required update.
        if (this.parent.parent) {
            messaging_1.MessageLoop.sendMessage(this.parent.parent, widget_1.Widget.Msg.FitRequest);
        }
        // If the dirty flag is still set, the parent was not resized.
        // Trigger the required update on the parent widget immediately.
        if (this._dirty) {
            messaging_1.MessageLoop.sendMessage(this.parent, widget_1.Widget.Msg.UpdateRequest);
        }
    };
    /**
     * Update the layout position and size of the widgets.
     *
     * The parent offset dimensions should be `-1` if unknown.
     */
    DockLayout.prototype._update = function (offsetWidth, offsetHeight) {
        // Clear the dirty flag to indicate the update occurred.
        this._dirty = false;
        // Bail early if there is no root layout node.
        if (!this._root) {
            return;
        }
        // Measure the parent if the offset dimensions are unknown.
        if (offsetWidth < 0) {
            offsetWidth = this.parent.node.offsetWidth;
        }
        if (offsetHeight < 0) {
            offsetHeight = this.parent.node.offsetHeight;
        }
        // Ensure the parent box sizing data is computed.
        if (!this._box) {
            this._box = domutils_1.ElementExt.boxSizing(this.parent.node);
        }
        // Compute the actual layout bounds adjusted for border and padding.
        var x = this._box.paddingTop;
        var y = this._box.paddingLeft;
        var width = offsetWidth - this._box.horizontalSum;
        var height = offsetHeight - this._box.verticalSum;
        // Update the geometry of the root layout node.
        Private.updateLayoutNode(this._root, x, y, width, height, this._spacing);
    };
    /**
     * Create a new tab bar for use by the dock layout.
     *
     * #### Notes
     * The tab bar will be attached to the parent if it exists.
     */
    DockLayout.prototype._createTabBar = function () {
        // Create the tab bar using the renderer.
        var tabBar = this.renderer.createTabBar();
        // Enforce necessary tab bar behavior.
        // TODO do we really want to enforce *all* of these?
        tabBar.tabsMovable = true;
        tabBar.allowDeselect = false;
        tabBar.orientation = 'horizontal';
        tabBar.removeBehavior = 'select-previous-tab';
        tabBar.insertBehavior = 'select-tab-if-needed';
        // Set up the signal handlers for the tab bar.
        tabBar.currentChanged.connect(this._onCurrentChanged, this);
        // Reparent and attach the tab bar to the parent if possible.
        if (this.parent) {
            tabBar.parent = this.parent;
            this.attachWidget(tabBar);
        }
        // Return the initialized tab bar.
        return tabBar;
    };
    /**
     * Create a new handle for the dock layout.
     *
     * #### Notes
     * The handle will be attached to the parent if it exists.
     */
    DockLayout.prototype._createHandle = function () {
        // Create the handle using the renderer.
        var handle = this.renderer.createHandle();
        // Initialize the handle layout behavior.
        var style = handle.style;
        style.position = 'absolute';
        style.top = '0';
        style.left = '0';
        style.width = '0';
        style.height = '0';
        // Attach the handle to the parent if it exists.
        if (this.parent) {
            this.parent.node.appendChild(handle);
        }
        // Return the initialized handle.
        return handle;
    };
    /**
     * Handle the `currentChanged` signal from a tab bar in the layout.
     */
    DockLayout.prototype._onCurrentChanged = function (sender, args) {
        // Extract the previous and current title from the args.
        var previousTitle = args.previousTitle, currentTitle = args.currentTitle;
        // Hide the previous widget.
        if (previousTitle) {
            previousTitle.owner.hide();
        }
        // Show the current widget.
        if (currentTitle) {
            currentTitle.owner.show();
        }
        // Flush the message loop on IE and Edge to prevent flicker.
        if (domutils_1.Platform.IS_EDGE || domutils_1.Platform.IS_IE) {
            messaging_1.MessageLoop.flush();
        }
    };
    return DockLayout;
}(layout_1.Layout));
exports.DockLayout = DockLayout;
/**
 * The namespace for the module implementation details.
 */
var Private;
(function (Private) {
    /**
     * A fraction used for sizing root panels; ~= `1 / golden_ratio`.
     */
    Private.GOLDEN_RATIO = 0.618;
    /**
     * A layout node which holds the data for a tabbed area.
     */
    var TabLayoutNode = (function () {
        /**
         * Construct a new tab layout node.
         *
         * @param tabBar - The tab bar to use for the layout node.
         */
        function TabLayoutNode(tabBar) {
            /**
             * The parent of the layout node.
             */
            this.parent = null;
            var tabSizer = new boxengine_1.BoxSizer();
            var widgetSizer = new boxengine_1.BoxSizer();
            tabSizer.stretch = 0;
            widgetSizer.stretch = 1;
            this.tabBar = tabBar;
            this.sizers = [tabSizer, widgetSizer];
        }
        return TabLayoutNode;
    }());
    Private.TabLayoutNode = TabLayoutNode;
    /**
     * A layout node which holds the data for a split area.
     */
    var SplitLayoutNode = (function () {
        /**
         * Construct a new split layout node.
         *
         * @param orientation - The orientation of the node.
         */
        function SplitLayoutNode(orientation) {
            /**
             * The parent of the layout node.
             */
            this.parent = null;
            /**
             * Whether the sizers have been normalized.
             */
            this.normalized = false;
            /**
             * The child nodes for the split node.
             */
            this.children = [];
            /**
             * The box sizers for the layout children.
             */
            this.sizers = [];
            /**
             * The handles for the layout children.
             */
            this.handles = [];
            this.orientation = orientation;
        }
        return SplitLayoutNode;
    }());
    Private.SplitLayoutNode = SplitLayoutNode;
    /**
     * Clamp a spacing value to an integer >= 0.
     */
    function clampSpacing(value) {
        return Math.max(0, Math.floor(value));
    }
    Private.clampSpacing = clampSpacing;
    /**
     * Create an iterator for all widgets in the layout tree.
     *
     * #### Notes
     * This includes the tab bars for the tab layout nodes.
     */
    function iterAllWidgets(node) {
        var it;
        if (node instanceof TabLayoutNode) {
            it = algorithm_1.chain(algorithm_1.once(node.tabBar), iterUserWidgets(node));
        }
        else {
            it = new algorithm_1.ChainIterator(algorithm_1.map(node.children, iterAllWidgets));
        }
        return it;
    }
    Private.iterAllWidgets = iterAllWidgets;
    /**
     * Create an iterator for the user widgets in the layout tree.
     *
     * #### Notes
     * This does not include the tab bars for the tab layout nodes.
     */
    function iterUserWidgets(node) {
        var it;
        if (node instanceof TabLayoutNode) {
            it = algorithm_1.map(node.tabBar.titles, function (title) { return title.owner; });
        }
        else {
            it = new algorithm_1.ChainIterator(algorithm_1.map(node.children, iterUserWidgets));
        }
        return it;
    }
    Private.iterUserWidgets = iterUserWidgets;
    /**
     * Create an iterator for the tab bars in the tree.
     */
    function iterTabBars(node) {
        var it;
        if (node instanceof TabLayoutNode) {
            it = algorithm_1.once(node.tabBar);
        }
        else {
            it = new algorithm_1.ChainIterator(algorithm_1.map(node.children, iterTabBars));
        }
        return it;
    }
    Private.iterTabBars = iterTabBars;
    /**
     * Create an iterator for the handles in the tree.
     */
    function iterHandles(node) {
        var it;
        if (node instanceof TabLayoutNode) {
            it = algorithm_1.empty();
        }
        else {
            var others = algorithm_1.map(node.children, iterHandles);
            it = algorithm_1.chain(node.handles, new algorithm_1.ChainIterator(others));
        }
        return it;
    }
    Private.iterHandles = iterHandles;
    /**
     * Find the first tab layout node in a layout tree.
     */
    function firstTabNode(node) {
        // Return the node if it's a tab layout node.
        if (node instanceof TabLayoutNode) {
            return node;
        }
        // Recursively search the children for a tab layout node.
        for (var i = 0, n = node.children.length; i < n; ++i) {
            var result = firstTabNode(node.children[i]);
            if (result) {
                return result;
            }
        }
        // Otherwise, there is no tab layout node.
        return null;
    }
    Private.firstTabNode = firstTabNode;
    /**
     * Find the tab layout node which contains the given widget.
     */
    function findTabNode(node, widget) {
        // Return the tab node if it contains the widget.
        if (node instanceof TabLayoutNode) {
            return node.tabBar.titles.indexOf(widget.title) !== -1 ? node : null;
        }
        // Recursively search the children of a split layout node.
        for (var i = 0, n = node.children.length; i < n; ++i) {
            var result = findTabNode(node.children[i], widget);
            if (result) {
                return result;
            }
        }
        // Otherwise, the widget does not exist in the tree.
        return null;
    }
    Private.findTabNode = findTabNode;
    /**
     * Find the split layout node which contains the given handle.
     */
    function findSplitNode(node, handle) {
        // Bail if the node is not a split node.
        if (node instanceof TabLayoutNode) {
            return null;
        }
        // Return the pair if the node contains the handle.
        var index = node.handles.indexOf(handle);
        if (index !== -1) {
            return { index: index, node: node };
        }
        // Recursively search the child split nodes.
        for (var i = 0, n = node.children.length; i < n; ++i) {
            var result = findSplitNode(node.children[i], handle);
            if (result) {
                return result;
            }
        }
        // Otherwise, the handle does not exist in the tree.
        return null;
    }
    Private.findSplitNode = findSplitNode;
    /**
     * Recursively fit the given layout node.
     */
    function fitLayoutNode(node, spacing) {
        var limits;
        if (node instanceof TabLayoutNode) {
            limits = fitTabNode(node);
        }
        else {
            limits = fitSplitNode(node, spacing);
        }
        return limits;
    }
    Private.fitLayoutNode = fitLayoutNode;
    /**
     * Recursively update the given layout node.
     */
    function updateLayoutNode(node, x, y, width, height, spacing) {
        if (node instanceof TabLayoutNode) {
            updateTabNode(node, x, y, width, height);
        }
        else {
            updateSplitNode(node, x, y, width, height, spacing);
        }
    }
    Private.updateLayoutNode = updateLayoutNode;
    /**
     * Create an area config object for a dock layout node.
     */
    function createAreaConfig(node) {
        var config;
        if (node instanceof TabLayoutNode) {
            config = createTabAreaConfig(node);
        }
        else {
            config = createSplitAreaConfig(node);
        }
        return config;
    }
    Private.createAreaConfig = createAreaConfig;
    /**
     * Valid a layout configuration object.
     */
    function validateLayoutConfig(config) {
        // Create the set to hold the contained widgets.
        var widgetSet = new Set();
        // Bail early if there is no main area.
        if (!config.main) {
            return widgetSet;
        }
        // Validate the main area.
        if (config.main.type === 'tab-area') {
            validateTabAreaConfig(config.main, widgetSet);
        }
        else {
            validateSplitAreaConfig(config.main, widgetSet);
        }
        // Return the contained widgets.
        return widgetSet;
    }
    Private.validateLayoutConfig = validateLayoutConfig;
    /**
     * Create a layout node for an area config.
     */
    function realizeAreaConfig(config, renderer) {
        var node;
        if (config.type === 'tab-area') {
            node = realizeTabAreaConfig(config, renderer);
        }
        else {
            node = realizeSplitAreaConfig(config, renderer);
        }
        return node;
    }
    Private.realizeAreaConfig = realizeAreaConfig;
    /**
     * Sync the visibility and orientation of split node handles.
     */
    function syncHandles(splitNode) {
        // Do nothing if there are no handles.
        if (splitNode.handles.length === 0) {
            return;
        }
        // Update the handle orientation and visibility.
        algorithm_1.each(splitNode.handles, function (handle, i) {
            if (splitNode.orientation === 'horizontal') {
                handle.classList.remove('p-mod-vertical');
                handle.classList.add('p-mod-horizontal');
            }
            else {
                handle.classList.remove('p-mod-horizontal');
                handle.classList.add('p-mod-vertical');
            }
            if (i === splitNode.handles.length - 1) {
                handle.classList.add('p-mod-hidden');
            }
            else {
                handle.classList.remove('p-mod-hidden');
            }
        });
    }
    Private.syncHandles = syncHandles;
    /**
     * Hold the current sizes of an array of box sizers.
     *
     * This sets the size hint of each sizer to its current size.
     */
    function holdSizes(sizers) {
        algorithm_1.each(sizers, function (sizer) { sizer.sizeHint = sizer.size; });
    }
    Private.holdSizes = holdSizes;
    /**
     * Recursively hold all the layout sizes in the tree.
     *
     * This ignores the sizers of tab layout nodes.
     */
    function holdLayoutSizes(node) {
        if (node instanceof SplitLayoutNode) {
            algorithm_1.each(node.children, holdLayoutSizes);
            holdSizes(node.sizers);
        }
    }
    Private.holdLayoutSizes = holdLayoutSizes;
    /**
     * Create a box sizer with an initial size hint.
     */
    function createSizer(hint) {
        var sizer = new boxengine_1.BoxSizer();
        sizer.sizeHint = hint;
        sizer.size = hint;
        return sizer;
    }
    Private.createSizer = createSizer;
    /**
     * Normalize the sizes of a split layout node.
     */
    function normalizeSizes(splitNode) {
        // Bail early if the sizers are empty.
        var n = splitNode.sizers.length;
        if (n === 0) {
            return;
        }
        // Hold the current sizes of the sizers.
        holdSizes(splitNode.sizers);
        // Compute the sum of the sizes.
        var sum = algorithm_1.reduce(splitNode.sizers, function (v, sizer) { return v + sizer.sizeHint; }, 0);
        // Normalize the sizes based on the sum.
        if (sum === 0) {
            algorithm_1.each(splitNode.sizers, function (sizer) {
                sizer.size = sizer.sizeHint = 1 / n;
            });
        }
        else {
            algorithm_1.each(splitNode.sizers, function (sizer) {
                sizer.size = sizer.sizeHint /= sum;
            });
        }
        // Mark the split node as normalized.
        splitNode.normalized = true;
    }
    Private.normalizeSizes = normalizeSizes;
    /**
     * Fit the given tab layout node.
     */
    function fitTabNode(tabNode) {
        // Set up the limit variables.
        var minWidth = 0;
        var minHeight = 0;
        var maxWidth = Infinity;
        var maxHeight = Infinity;
        // Lookup common variables.
        var tabBar = tabNode.tabBar;
        var tabSizer = tabNode.sizers[0];
        var widgetSizer = tabNode.sizers[1];
        var currentTitle = tabBar.currentTitle;
        var widget = currentTitle ? currentTitle.owner : null;
        // Adjust the starting max height if a widget is visible.
        if (!tabBar.isHidden || (widget && !widget.isHidden)) {
            maxHeight = 0;
        }
        // Update the results and sizer for the tab bar.
        if (!tabBar.isHidden) {
            var limits = domutils_1.ElementExt.sizeLimits(tabBar.node);
            minWidth = Math.max(minWidth, limits.minWidth);
            maxWidth = Math.min(maxWidth, limits.maxWidth);
            minHeight += limits.minHeight;
            maxHeight += limits.maxHeight;
            tabSizer.minSize = limits.minHeight;
            tabSizer.maxSize = limits.maxHeight;
        }
        else {
            tabSizer.minSize = 0;
            tabSizer.maxSize = 0;
        }
        // Update the results and sizer for the current widget.
        if (widget && !widget.isHidden) {
            var limits = domutils_1.ElementExt.sizeLimits(widget.node);
            minWidth = Math.max(minWidth, limits.minWidth);
            maxWidth = Math.min(maxWidth, limits.maxWidth);
            minHeight += limits.minHeight;
            maxHeight += limits.maxHeight;
            widgetSizer.minSize = limits.minHeight;
            widgetSizer.maxSize = limits.maxHeight;
        }
        else {
            widgetSizer.minSize = 0;
            widgetSizer.maxSize = 0;
        }
        // Return the computed size limits for the layout node.
        return { minWidth: minWidth, minHeight: minHeight, maxWidth: maxWidth, maxHeight: maxHeight };
    }
    /**
     * Recursively fit the given split layout node.
     */
    function fitSplitNode(splitNode, spacing) {
        // Set up the limit variables.
        var minWidth = 0;
        var minHeight = 0;
        var maxWidth = Infinity;
        var maxHeight = Infinity;
        // Compute common values.
        var horizontal = splitNode.orientation === 'horizontal';
        var fixed = Math.max(0, splitNode.children.length - 1) * spacing;
        // Adjust the starting limits for the orientation.
        if (horizontal) {
            minWidth = fixed;
            maxWidth = fixed;
        }
        else {
            minHeight = fixed;
            maxHeight = fixed;
        }
        // Adjust the limits and sizer for each child area.
        for (var i = 0, n = splitNode.children.length; i < n; ++i) {
            var sizer = splitNode.sizers[i];
            var child = splitNode.children[i];
            var limits = fitLayoutNode(child, spacing);
            if (horizontal) {
                minHeight = Math.max(minHeight, limits.minHeight);
                maxHeight = Math.min(maxHeight, limits.maxHeight);
                minWidth += limits.minWidth;
                maxWidth += limits.maxWidth;
                sizer.minSize = limits.minWidth;
                sizer.maxSize = limits.maxWidth;
            }
            else {
                minWidth = Math.max(minWidth, limits.minWidth);
                maxWidth = Math.min(maxWidth, limits.maxWidth);
                minHeight += limits.minHeight;
                maxHeight += limits.maxHeight;
                sizer.minSize = limits.minHeight;
                sizer.maxSize = limits.maxHeight;
            }
        }
        // Return the computed size limits for the layout node.
        return { minWidth: minWidth, minHeight: minHeight, maxWidth: maxWidth, maxHeight: maxHeight };
    }
    /**
     * Update the given tab layout node.
     */
    function updateTabNode(tabNode, x, y, width, height) {
        // Lookup common variables.
        var tabBar = tabNode.tabBar;
        var tabSizer = tabNode.sizers[0];
        var widgetSizer = tabNode.sizers[1];
        var currentTitle = tabBar.currentTitle;
        var widget = currentTitle ? currentTitle.owner : null;
        // Distribute the layout space to the sizers.
        boxengine_1.BoxEngine.calc(tabNode.sizers, height);
        // Layout the tab bar using the computed size.
        if (!tabBar.isHidden) {
            widget_1.Widget.setGeometry(tabBar, x, y, width, tabSizer.size);
            y += tabSizer.size;
        }
        // Layout the widget using the computed size.
        if (widget && !widget.isHidden) {
            widget_1.Widget.setGeometry(widget, x, y, width, widgetSizer.size);
        }
    }
    /**
     * Update the given split layout node.
     */
    function updateSplitNode(splitNode, x, y, width, height, spacing) {
        // Compute the available layout space.
        var horizontal = splitNode.orientation === 'horizontal';
        var fixed = Math.max(0, splitNode.children.length - 1) * spacing;
        var space = Math.max(0, (horizontal ? width : height) - fixed);
        // De-normalize the split node if needed.
        if (splitNode.normalized) {
            algorithm_1.each(splitNode.sizers, function (sizer) { sizer.sizeHint *= space; });
            splitNode.normalized = false;
        }
        // Distribute the layout space to the sizers.
        boxengine_1.BoxEngine.calc(splitNode.sizers, space);
        // Update the geometry of the child areas and handles.
        for (var i = 0, n = splitNode.children.length; i < n; ++i) {
            var child = splitNode.children[i];
            var size = splitNode.sizers[i].size;
            var handleStyle = splitNode.handles[i].style;
            if (horizontal) {
                updateLayoutNode(child, x, y, size, height, spacing);
                x += size;
                handleStyle.top = y + "px";
                handleStyle.left = x + "px";
                handleStyle.width = spacing + "px";
                handleStyle.height = height + "px";
                x += spacing;
            }
            else {
                updateLayoutNode(child, x, y, width, size, spacing);
                y += size;
                handleStyle.top = y + "px";
                handleStyle.left = x + "px";
                handleStyle.width = width + "px";
                handleStyle.height = spacing + "px";
                y += spacing;
            }
        }
    }
    /**
     * Create the tab area configuration for a tab layout node.
     */
    function createTabAreaConfig(node) {
        var widgets = node.tabBar.titles.map(function (title) { return title.owner; });
        var currentIndex = node.tabBar.currentIndex;
        return { type: 'tab-area', widgets: widgets, currentIndex: currentIndex };
    }
    /**
     * Create the split area configuration for a split layout node.
     */
    function createSplitAreaConfig(node) {
        var orientation = node.orientation;
        var children = node.children.map(createAreaConfig);
        var sizes = createNormalizedSizes(node);
        return { type: 'split-area', orientation: orientation, children: children, sizes: sizes };
    }
    /**
     * Snap the normalized sizes of a split layout node.
     */
    function createNormalizedSizes(splitNode) {
        // Bail early if the sizers are empty.
        var n = splitNode.sizers.length;
        if (n === 0) {
            return [];
        }
        // Grab the current sizes of the sizers.
        var sizes = splitNode.sizers.map(function (sizer) { return sizer.size; });
        // Compute the sum of the sizes.
        var sum = algorithm_1.reduce(sizes, function (v, size) { return v + size; }, 0);
        // Normalize the sizes based on the sum.
        if (sum === 0) {
            algorithm_1.each(sizes, function (size, i) { sizes[i] = 1 / n; });
        }
        else {
            algorithm_1.each(sizes, function (size, i) { sizes[i] = size / sum; });
        }
        // Return the normalized sizes.
        return sizes;
    }
    /**
     * Validate a tab area config and collect the visited widgets.
     */
    function validateTabAreaConfig(config, widgetSet) {
        algorithm_1.each(config.widgets, function (widget) {
            if (widgetSet.has(widget)) {
                throw new Error('Layout config has duplicate widget.');
            }
            widgetSet.add(widget);
        });
    }
    /**
     * Validate a split area config and collect the visited widgets.
     */
    function validateSplitAreaConfig(config, widgetSet) {
        if (config.sizes.length !== config.children.length) {
            throw new Error('Split area config has mismatched sizes count.');
        }
        if (config.sizes.some(function (size) { return size < 0; })) {
            throw new Error('Split area config has negative sizes.');
        }
        algorithm_1.each(config.children, function (child) { return validateChildAreaConfig(config, child, widgetSet); });
    }
    /**
     * Validate a child area config.
     */
    function validateChildAreaConfig(parent, child, widgetSet) {
        if (child.type === 'tab-area') {
            validateTabAreaConfig(child, widgetSet);
        }
        else if (parent.orientation === child.orientation) {
            throw new Error('Child split area config has invalid orientation.');
        }
        else {
            validateSplitAreaConfig(child, widgetSet);
        }
    }
    /**
     * Create a new layout node for a tab area config.
     */
    function realizeTabAreaConfig(config, renderer) {
        // Create the tab bar for the layout node.
        var tabBar = renderer.createTabBar();
        // Hide each widget and add it to the tab bar.
        algorithm_1.each(config.widgets, function (widget) {
            widget.hide();
            tabBar.addTab(widget.title);
        });
        // Set the current index of the tab bar.
        var n = tabBar.titles.length;
        tabBar.currentIndex = Math.max(0, Math.min(config.currentIndex, n - 1));
        // Return the new tab layout node.
        return new TabLayoutNode(tabBar);
    }
    /**
     * Create a new layout node for a split area config.
     */
    function realizeSplitAreaConfig(config, renderer) {
        // Create the split layout node.
        var node = new SplitLayoutNode(config.orientation);
        // Add each child to the split layout node.
        algorithm_1.each(config.children, function (child, i) {
            // Recursively create the child layout node.
            var childNode = realizeAreaConfig(child, renderer);
            // Create the sizer for the child.
            var sizer = createSizer(config.sizes[i]);
            // Create the handle for the child.
            var handle = renderer.createHandle();
            // Add the child data to the layout node.
            node.children.push(childNode);
            node.handles.push(handle);
            node.sizers.push(sizer);
            // Update the parent for the child node.
            childNode.parent = node;
        });
        // Synchronize the handle state for the split layout node.
        syncHandles(node);
        // Normalize the sizes for the split layout node.
        normalizeSizes(node);
        // Return the new split layout node.
        return node;
    }
})(Private || (Private = {}));
