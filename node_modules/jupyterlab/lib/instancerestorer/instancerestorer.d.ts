import { Token } from '@phosphor/application';
import { CommandRegistry } from '@phosphor/commands';
import { JSONObject } from '@phosphor/coreutils';
import { Widget } from '@phosphor/widgets';
import { InstanceTracker } from '../common/instancetracker';
import { IStateDB } from '../statedb';
/**
 * The instance restorer token.
 */
export declare const IInstanceRestorer: Token<IInstanceRestorer>;
/**
 * A static class that restores the widgets of the application when it reloads.
 */
export interface IInstanceRestorer {
    /**
     * A promise resolved when the instance restorer is ready to receive signals.
     */
    restored: Promise<void>;
    /**
     * Add a widget to be tracked by the instance restorer.
     */
    add(widget: Widget, name: string): void;
    /**
     * Restore the widgets of a particular instance tracker.
     *
     * @param tracker - The instance tracker whose widgets will be restored.
     *
     * @param options - The restoration options.
     */
    restore(tracker: InstanceTracker<any>, options: IInstanceRestorer.IRestoreOptions<any>): void;
}
/**
 * A namespace for instance restorers.
 */
export declare namespace IInstanceRestorer {
    /**
     * An application layout data store.
     */
    interface ILayoutDB {
        /**
         * Fetch the layout state for the application.
         *
         * #### Notes
         * Fetching the layout relies on all widget restoration to be complete, so
         * calls to `fetch` are guaranteed to return after restoration is complete.
         */
        fetch(): Promise<IInstanceRestorer.ILayout>;
        /**
         * Save the layout state for the application.
         */
        save(data: IInstanceRestorer.ILayout): Promise<void>;
    }
    /**
     * A description of the application's user interface layout.
     */
    interface ILayout {
        /**
         * The current widget that has application focus.
         */
        readonly currentWidget: Widget | null;
        /**
         * Indicates whether fetched session restore data was actually retrieved
         * from the state database or whether it is a fresh blank slate.
         *
         * #### Notes
         * This attribute is only relevant when the layout data is retrieved via a
         * `fetch` call. If it is set when being passed into `save`, it will be
         * ignored.
         */
        readonly fresh?: boolean;
        /**
         * The left area of the user interface.
         */
        readonly leftArea: ISideArea;
        /**
         * The right area of the user interface.
         */
        readonly rightArea: ISideArea;
    }
    /**
     * The restorable description of a sidebar in the user interface.
     */
    interface ISideArea {
        /**
         * A flag denoting whether the sidebar has been collapsed.
         */
        readonly collapsed: boolean;
        /**
         * The current widget that has side area focus.
         */
        readonly currentWidget: Widget | null;
        /**
         * The collection of widgets held by the sidebar.
         */
        readonly widgets: Array<Widget> | null;
    }
    /**
     * The state restoration configuration options.
     */
    interface IRestoreOptions<T extends Widget> {
        /**
         * The command to execute when restoring instances.
         */
        command: string;
        /**
         * A function that returns the args needed to restore an instance.
         */
        args: (widget: T) => JSONObject;
        /**
         * A function that returns a unique persistent name for this instance.
         */
        name: (widget: T) => string;
        /**
         * The point after which it is safe to restore state.
         *
         * #### Notes
         * By definition, this promise or promises will happen after the application
         * has `started`.
         */
        when?: Promise<any> | Array<Promise<any>>;
    }
}
/**
 * The default implementation of an instance restorer.
 *
 * #### Notes
 * The lifecycle for state restoration is subtle. The sequence of events is:
 *
 * 1. The instance restorer plugin is instantiated. It installs itself as the
 *    layout database that the application shell can use to `fetch` and `save`
 *    layout restoration data.
 *
 * 2. Other plugins that care about state restoration require the instance
 *    restorer as a dependency.
 *
 * 3. As each load-time plugin initializes (which happens before the lab
 *    application has `started`), it instructs the instance restorer whether
 *    the restorer ought to `restore` its state by passing in its tracker.
 *    Alternatively, a plugin that does not require its own instance tracker
 *    (because perhaps it only creates a single widget, like a command palette),
 *    can simply `add` its widget along with a persistent unique name to the
 *    instance restorer so that its layout state can be restored when the lab
 *    application restores.
 *
 * 4. After all the load-time plugins have finished initializing, the lab
 *    application `started` promise will resolve. This is the `first`
 *    promise that the instance restorer waits for. By this point, all of the
 *    plugins that care about restoration will have instructed the instance
 *    restorer to `restore` their state.
 *
 * 5. The instance restorer will then instruct each plugin's instance tracker
 *    to restore its state and reinstantiate whichever widgets it wants. The
 *    tracker returns a promise to the instance restorer that resolves when it
 *    has completed restoring the tracked widgets it cares about.
 *
 * 6. As each instance finishes restoring, it resolves the promise that was
 *    made to the instance restorer (in step 5). After all of the promises that
 *    the restorer is awaiting have resolved, the restorer then resolves its
 *    `restored` promise allowing the application shell to rehydrate its saved
 *    layout.
 *
 * Of particular note are steps 5 and 6: since state restoration of plugins
 * is accomplished by executing commands, the command that is used to restore
 * the state of each plugin must return a promise that only resolves when the
 * widget has been created and added to the plugin's instance tracker.
 */
export declare class InstanceRestorer implements IInstanceRestorer {
    /**
     * Create an instance restorer.
     */
    constructor(options: InstanceRestorer.IOptions);
    /**
     * A promise resolved when the instance restorer is ready to receive signals.
     */
    readonly restored: Promise<void>;
    /**
     * Add a widget to be tracked by the instance restorer.
     */
    add(widget: Widget, name: string): void;
    /**
     * Fetch the layout state for the application.
     *
     * #### Notes
     * Fetching the layout relies on all widget restoration to be complete, so
     * calls to `fetch` are guaranteed to return after restoration is complete.
     */
    fetch(): Promise<IInstanceRestorer.ILayout>;
    /**
     * Restore the widgets of a particular instance tracker.
     *
     * @param tracker - The instance tracker whose widgets will be restored.
     *
     * @param options - The restoration options.
     */
    restore(tracker: InstanceTracker<Widget>, options: IInstanceRestorer.IRestoreOptions<Widget>): Promise<any>;
    /**
     * Save the layout state for the application.
     */
    save(data: IInstanceRestorer.ILayout): Promise<void>;
    /**
     * Dehydrate a side area into a serialized description object.
     */
    private _dehydrateSideArea(area);
    /**
     * Reydrate a serialized side area description object.
     *
     * #### Notes
     * This function consumes data that can become corrupted, so it uses type
     * coercion to guarantee the dehydrated object is safely processed.
     */
    private _rehydrateSideArea(area);
    /**
     * Handle a widget disposal.
     */
    private _onWidgetDisposed(widget);
    private _first;
    private _promises;
    private _restored;
    private _registry;
    private _state;
    private _trackers;
    private _widgets;
}
/**
 * A namespace for `InstanceRestorer` statics.
 */
export declare namespace InstanceRestorer {
    /**
     * The configuration options for instance restorer instantiation.
     */
    interface IOptions {
        /**
         * The initial promise that has to be resolved before restoration.
         *
         * #### Notes
         * This promise should equal the JupyterLab application `started` notifier.
         */
        first: Promise<any>;
        /**
         * The application command registry.
         */
        registry: CommandRegistry;
        /**
         * The state database instance.
         */
        state: IStateDB;
    }
    /**
     * The dehydrated state of the application layout.
     *
     * #### Notes
     * This format is JSON serializable and only used internally by the instance
     * restorer to read and write to the state database. It is meant to be a data
     * structure that the instance restorer can translate into an
     * `IInstanceTracker.ILayout` data structure for consumption by the
     * application shell.
     */
    interface IDehydratedLayout extends JSONObject {
        /**
         * The current widget that has application focus.
         */
        current?: string | null;
        /**
         * The left area of the user interface.
         */
        left?: ISideArea | null;
        /**
         * The right area of the user interface.
         */
        right?: ISideArea | null;
    }
    /**
     * The restorable description of a sidebar in the user interface.
     */
    interface ISideArea extends JSONObject {
        /**
         * A flag denoting whether the sidebar has been collapsed.
         */
        collapsed?: boolean | null;
        /**
         * The current widget that has side area focus.
         */
        current?: string | null;
        /**
         * The collection of widgets held by the sidebar.
         */
        widgets?: Array<string> | null;
    }
}
