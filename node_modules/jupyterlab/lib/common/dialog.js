// Copyright (c) Jupyter Development Team.
// Distributed under the terms of the Modified BSD License.
"use strict";
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var widgets_1 = require("@phosphor/widgets");
var widgets_2 = require("@phosphor/widgets");
/**
 * The class name added to dialog instances.
 */
var DIALOG_CLASS = 'jp-Dialog';
/**
 * The class name added to dialog content node.
 */
var CONTENT_CLASS = 'jp-Dialog-content';
/**
 * The class name added to dialog header node.
 */
var HEADER_CLASS = 'jp-Dialog-header';
/**
 * The class name added to dialog title node.
 */
var TITLE_CLASS = 'jp-Dialog-title';
/**
 * The class name added to dialog body node.
 */
var BODY_CLASS = 'jp-Dialog-body';
/**
 * The class name added to a dialog body content node.
 */
var BODY_CONTENT_CLASS = 'jp-Dialog-bodyContent';
/**
 * The class name added to a dialog content node.
 */
var FOOTER_CLASS = 'jp-Dialog-footer';
/**
 * The class name added to a dialog button node.
 */
var BUTTON_CLASS = 'jp-Dialog-button';
/**
 * The class name added to a dialog button icon node.
 */
var BUTTON_ICON_CLASS = 'jp-Dialog-buttonIcon';
/**
 * The class name added to a dialog button text node.
 */
var BUTTON_TEXT_CLASS = 'jp-Dialog-buttonText';
/*
 * The class name added to dialog Confirm buttons.
 */
var OK_BUTTON_CLASS = 'jp-Dialog-okButton';
/**
 * The class name added to dialog Cancel buttons.
 */
var CANCEL_BUTTON_CLASS = 'jp-Dialog-cancelButton';
/**
 * The class name added to dialog Warning buttons.
 */
var WARNING_BUTTON_CLASS = 'jp-Dialog-warningButton';
/**
 * The class name added to dialog input field wrappers.
 */
var INPUT_WRAPPER_CLASS = 'jp-Dialog-inputWrapper';
/**
 * The class name added to dialog input fields.
 */
var INPUT_CLASS = 'jp-Dialog-input';
/**
 * The class name added to dialog select wrappers.
 */
var SELECT_WRAPPER_CLASS = 'jp-Dialog-selectWrapper';
/**
 * The class name added to dialog select nodes.
 */
var SELECT_CLASS = 'jp-Dialog-select';
/**
 * The class name added to focused input and select wrappers.
 */
var FOCUS_CLASS = 'jp-mod-focused';
/**
 * A default confirmation button.
 */
exports.okButton = {
    text: 'OK',
    className: OK_BUTTON_CLASS
};
/**
 * A default cancel button.
 */
exports.cancelButton = {
    text: 'CANCEL',
    className: CANCEL_BUTTON_CLASS
};
/**
 * A default delete button.
 */
exports.deleteButton = {
    text: 'DELETE',
    className: WARNING_BUTTON_CLASS
};
/**
 * A default warn button.
 */
exports.warnButton = {
    text: 'OK',
    className: WARNING_BUTTON_CLASS
};
/**
 * Create a dialog and show it.
 *
 * @param options - The dialog setup options.
 *
 * @returns A promise that resolves to the button item that was selected.
 */
function showDialog(options) {
    options = options || {};
    var host = options.host || document.body;
    options.host = host;
    options.body = options.body || '';
    // NOTE: This code assumes only one dialog is shown at the time:
    exports.okButton.text = options.okText ? options.okText : 'OK';
    options.buttons = options.buttons || [exports.cancelButton, exports.okButton];
    if (!options.buttons.length) {
        options.buttons = [exports.okButton];
    }
    if (!(options.body instanceof widgets_2.Widget)) {
        options.body = createDialogBody(options.body);
    }
    return new Promise(function (resolve, reject) {
        var dialog = new Dialog(options, resolve, reject);
        widgets_2.Widget.attach(dialog, host);
    });
}
exports.showDialog = showDialog;
/**
 * A dialog panel.
 */
var Dialog = (function (_super) {
    __extends(Dialog, _super);
    /**
     * Create a dialog panel instance.
     *
     * @param options - The dialog setup options.
     *
     * @param resolve - The function that resolves the dialog promise.
     *
     * @param reject - The function that rejects the dialog promise.
     *
     * #### Notes
     * Currently the dialog resolves with `cancelButton` rather than
     * rejecting the dialog promise.
     */
    function Dialog(options, resolve, reject) {
        var _this = _super.call(this) || this;
        if (!(options.body instanceof widgets_2.Widget)) {
            throw 'A widget dialog can only be created with a widget as its body.';
        }
        _this.resolve = resolve;
        _this.reject = reject;
        // Create the dialog nodes (except for the buttons).
        var content = new widgets_1.Panel();
        var header = new widgets_2.Widget({ node: document.createElement('div') });
        var body = new widgets_1.Panel();
        var footer = new widgets_2.Widget({ node: document.createElement('div') });
        var title = document.createElement('span');
        _this.addClass(DIALOG_CLASS);
        if (options.dialogClass) {
            _this.addClass(options.dialogClass);
        }
        content.addClass(CONTENT_CLASS);
        header.addClass(HEADER_CLASS);
        body.addClass(BODY_CLASS);
        footer.addClass(FOOTER_CLASS);
        title.className = TITLE_CLASS;
        _this.addWidget(content);
        content.addWidget(header);
        content.addWidget(body);
        content.addWidget(footer);
        header.node.appendChild(title);
        // Populate the nodes.
        title.textContent = options.title || '';
        var child = options.body;
        child.addClass(BODY_CONTENT_CLASS);
        body.addWidget(child);
        _this._buttons = options.buttons.slice();
        _this._buttonNodes = options.buttons.map(createButton);
        _this._buttonNodes.map(function (buttonNode) {
            footer.node.appendChild(buttonNode);
        });
        var primary = options.primary || _this.lastButtonNode;
        if (typeof primary === 'number') {
            primary = _this._buttonNodes[primary];
        }
        _this._primary = primary;
        return _this;
    }
    Object.defineProperty(Dialog.prototype, "lastButtonNode", {
        /**
         * Get the last button node.
         */
        get: function () {
            return this._buttonNodes[this._buttons.length - 1];
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Handle the DOM events for the directory listing.
     *
     * @param event - The DOM event sent to the widget.
     *
     * #### Notes
     * This method implements the DOM `EventListener` interface and is
     * called in response to events on the panel's DOM node. It should
     * not be called directly by user code.
     */
    Dialog.prototype.handleEvent = function (event) {
        switch (event.type) {
            case 'keydown':
                this._evtKeydown(event);
                break;
            case 'contextmenu':
                this._evtContextMenu(event);
                break;
            case 'click':
                this._evtClick(event);
                break;
            case 'focus':
                this._evtFocus(event);
                break;
            case 'blur':
                this._evtBlur(event);
                break;
            default:
                break;
        }
    };
    /**
     * Handle an `'after-attach'` message to the widget.
     *
     * @param msg - The `'after-attach'` message
     */
    Dialog.prototype.onAfterAttach = function (msg) {
        var node = this.node;
        node.addEventListener('keydown', this, true);
        node.addEventListener('contextmenu', this, true);
        node.addEventListener('click', this, true);
        document.addEventListener('focus', this, true);
        document.addEventListener('blur', this, true);
        this._original = document.activeElement;
        this._primary.focus();
    };
    /**
     * Handle a `'before-detach'` message to the widget.
     *
     * @param msg - The `'after-attach'` message
     */
    Dialog.prototype.onBeforeDetach = function (msg) {
        var node = this.node;
        node.removeEventListener('keydown', this, true);
        node.removeEventListener('contextmenu', this, true);
        node.removeEventListener('click', this, true);
        document.removeEventListener('focus', this, true);
        document.removeEventListener('blur', this, true);
        this._original.focus();
    };
    /**
     * Handle the `'click'` event for a dialog button.
     *
     * @param event - The DOM event sent to the widget
     */
    Dialog.prototype._evtClick = function (event) {
        var content = this.node.getElementsByClassName(CONTENT_CLASS)[0];
        if (!content.contains(event.target)) {
            this.close();
            this.resolve(exports.cancelButton);
            event.stopPropagation();
            return;
        }
        for (var _i = 0, _a = this._buttonNodes; _i < _a.length; _i++) {
            var buttonNode = _a[_i];
            if (buttonNode.contains(event.target)) {
                this.close();
                var button = this._buttons[this._buttonNodes.indexOf(buttonNode)];
                this.resolve(button);
            }
        }
    };
    /**
     * Handle the `'keydown'` event for the widget.
     *
     * @param event - The DOM event sent to the widget
     */
    Dialog.prototype._evtKeydown = function (event) {
        // Check for escape key
        switch (event.keyCode) {
            case 27:
                this.close();
                this.resolve(exports.cancelButton);
                break;
            case 9:
                // Handle a tab on the last button.
                if (document.activeElement === this.lastButtonNode && !event.shiftKey) {
                    event.stopPropagation();
                    event.preventDefault();
                    if (!this._first) {
                        this._findFirst();
                    }
                    this._first.focus();
                }
                break;
            case 13:
                this.close();
                this.resolve(this._buttons[this._buttons.length - 1]);
                break;
            default:
                break;
        }
    };
    /**
     * Handle the `'focus'` event for the widget.
     *
     * @param event - The DOM event sent to the widget
     */
    Dialog.prototype._evtFocus = function (event) {
        var target = event.target;
        if (!this.node.contains(target)) {
            event.stopPropagation();
            this.lastButtonNode.focus();
        }
        else {
            // Add the focus modifier class to input and select wrappers.
            if (target.classList.contains(INPUT_CLASS) ||
                target.classList.contains(SELECT_CLASS)) {
                var parent_1 = target.parentElement;
                parent_1.classList.add(FOCUS_CLASS);
            }
        }
    };
    /**
     * Handle the `'blur'` event for the widget.
     *
     * @param event - The DOM event sent to the widget
     */
    Dialog.prototype._evtBlur = function (event) {
        var target = event.target;
        // Remove the focus modifier class to input and select wrappers.
        if (target.classList.contains(INPUT_CLASS) ||
            target.classList.contains(SELECT_CLASS)) {
            var parent_2 = target.parentElement;
            parent_2.classList.remove(FOCUS_CLASS);
        }
    };
    /**
     * Handle the `'contextmenu'` event for the widget.
     *
     * @param event - The DOM event sent to the widget
     */
    Dialog.prototype._evtContextMenu = function (event) {
        event.preventDefault();
        event.stopPropagation();
    };
    /**
     * Find the first focusable item in the dialog.
     */
    Dialog.prototype._findFirst = function () {
        var candidateSelectors = [
            'input',
            'select',
            'a[href]',
            'textarea',
            'button',
            '[tabindex]',
        ].join(',');
        this._first = this.node.querySelectorAll(candidateSelectors)[0];
    };
    return Dialog;
}(widgets_1.Panel));
/**
 * Create a dialog body widget from a non-widget input.
 */
function createDialogBody(body) {
    var child;
    if (typeof body === 'string') {
        child = document.createElement('span');
        child.innerHTML = body;
    }
    else if (body) {
        child = body;
        switch (child.tagName) {
            case 'INPUT':
                child = wrapInput(child);
                break;
            case 'SELECT':
                child = wrapSelect(child);
                break;
            default:
                child = styleElements(child);
                break;
        }
    }
    child.classList.add(BODY_CONTENT_CLASS);
    return new widgets_2.Widget({ node: child });
}
/**
 * Style the child elements of a parent element.
 */
function styleElements(element) {
    for (var i = 0; i < element.children.length; i++) {
        var child = element.children[i];
        var next = child.nextSibling;
        switch (child.tagName) {
            case 'INPUT':
                child = wrapInput(child);
                element.insertBefore(child, next);
                break;
            case 'SELECT':
                child = wrapSelect(child);
                element.insertBefore(child, next);
                break;
            default:
                break;
        }
    }
    return element;
}
/**
 * Create a node for a button item.
 */
function createButton(item) {
    var button = document.createElement('button');
    button.className = BUTTON_CLASS;
    button.tabIndex = 0;
    if (item.className) {
        button.classList.add(item.className);
    }
    var icon = document.createElement('span');
    icon.className = BUTTON_ICON_CLASS;
    if (item.icon) {
        icon.classList.add(item.icon);
    }
    var text = document.createElement('span');
    text.className = BUTTON_TEXT_CLASS;
    text.textContent = item.text;
    button.appendChild(icon);
    button.appendChild(text);
    return button;
}
/**
 * Wrap and style an input node.
 */
function wrapInput(input) {
    var wrapper = document.createElement('div');
    wrapper.className = INPUT_WRAPPER_CLASS;
    wrapper.appendChild(input);
    input.classList.add(INPUT_CLASS);
    input.tabIndex = 0;
    return wrapper;
}
/**
 * Wrap and style a select node.
 */
function wrapSelect(select) {
    var wrapper = document.createElement('div');
    wrapper.className = SELECT_WRAPPER_CLASS;
    wrapper.appendChild(select);
    select.classList.add(SELECT_CLASS);
    select.tabIndex = 0;
    return wrapper;
}
//# sourceMappingURL=dialog.js.map