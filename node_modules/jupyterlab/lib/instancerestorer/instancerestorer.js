/*-----------------------------------------------------------------------------
| Copyright (c) Jupyter Development Team.
| Distributed under the terms of the Modified BSD License.
|----------------------------------------------------------------------------*/
"use strict";
var application_1 = require("@phosphor/application");
var coreutils_1 = require("@phosphor/coreutils");
var properties_1 = require("@phosphor/properties");
/* tslint:disable */
/**
 * The instance restorer token.
 */
exports.IInstanceRestorer = new application_1.Token('jupyter.services.instance-restorer');
/**
 * The state database key for restorer data.
 */
var KEY = 'instance-restorer:data';
/**
 * The default implementation of an instance restorer.
 *
 * #### Notes
 * The lifecycle for state restoration is subtle. The sequence of events is:
 *
 * 1. The instance restorer plugin is instantiated. It installs itself as the
 *    layout database that the application shell can use to `fetch` and `save`
 *    layout restoration data.
 *
 * 2. Other plugins that care about state restoration require the instance
 *    restorer as a dependency.
 *
 * 3. As each load-time plugin initializes (which happens before the lab
 *    application has `started`), it instructs the instance restorer whether
 *    the restorer ought to `restore` its state by passing in its tracker.
 *    Alternatively, a plugin that does not require its own instance tracker
 *    (because perhaps it only creates a single widget, like a command palette),
 *    can simply `add` its widget along with a persistent unique name to the
 *    instance restorer so that its layout state can be restored when the lab
 *    application restores.
 *
 * 4. After all the load-time plugins have finished initializing, the lab
 *    application `started` promise will resolve. This is the `first`
 *    promise that the instance restorer waits for. By this point, all of the
 *    plugins that care about restoration will have instructed the instance
 *    restorer to `restore` their state.
 *
 * 5. The instance restorer will then instruct each plugin's instance tracker
 *    to restore its state and reinstantiate whichever widgets it wants. The
 *    tracker returns a promise to the instance restorer that resolves when it
 *    has completed restoring the tracked widgets it cares about.
 *
 * 6. As each instance finishes restoring, it resolves the promise that was
 *    made to the instance restorer (in step 5). After all of the promises that
 *    the restorer is awaiting have resolved, the restorer then resolves its
 *    `restored` promise allowing the application shell to rehydrate its saved
 *    layout.
 *
 * Of particular note are steps 5 and 6: since state restoration of plugins
 * is accomplished by executing commands, the command that is used to restore
 * the state of each plugin must return a promise that only resolves when the
 * widget has been created and added to the plugin's instance tracker.
 */
var InstanceRestorer = (function () {
    /**
     * Create an instance restorer.
     */
    function InstanceRestorer(options) {
        var _this = this;
        this._first = null;
        this._promises = [];
        this._restored = new coreutils_1.PromiseDelegate();
        this._registry = null;
        this._state = null;
        this._trackers = new Set();
        this._widgets = new Map();
        this._registry = options.registry;
        this._state = options.state;
        this._first = options.first;
        this._first.then(function () { return Promise.all(_this._promises); }).then(function () {
            // Release the promises held in memory.
            _this._promises = null;
            // Release the tracker set.
            _this._trackers.clear();
            _this._trackers = null;
        }).then(function () { _this._restored.resolve(void 0); });
    }
    Object.defineProperty(InstanceRestorer.prototype, "restored", {
        /**
         * A promise resolved when the instance restorer is ready to receive signals.
         */
        get: function () {
            return this._restored.promise;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Add a widget to be tracked by the instance restorer.
     */
    InstanceRestorer.prototype.add = function (widget, name) {
        Private.nameProperty.set(widget, name);
        this._widgets.set(name, widget);
        widget.disposed.connect(this._onWidgetDisposed, this);
    };
    /**
     * Fetch the layout state for the application.
     *
     * #### Notes
     * Fetching the layout relies on all widget restoration to be complete, so
     * calls to `fetch` are guaranteed to return after restoration is complete.
     */
    InstanceRestorer.prototype.fetch = function () {
        var _this = this;
        var blank = {
            currentWidget: null,
            fresh: true,
            leftArea: { collapsed: true, currentWidget: null, widgets: null },
            rightArea: { collapsed: true, currentWidget: null, widgets: null }
        };
        var layout = this._state.fetch(KEY);
        return Promise.all([layout, this.restored]).then(function (_a) {
            var data = _a[0];
            if (!data) {
                return blank;
            }
            var _b = data, current = _b.current, left = _b.left, right = _b.right;
            // If any data exists, then this is not a fresh session.
            var fresh = false;
            // Rehydrate main area. Coerce type of `current` in case of bad data.
            var currentWidget = current && _this._widgets.has("" + current) ?
                _this._widgets.get("" + current) : null;
            // Rehydrate left area.
            var leftArea = _this._rehydrateSideArea(left);
            // Rehydrate right area.
            var rightArea = _this._rehydrateSideArea(right);
            return { currentWidget: currentWidget, fresh: fresh, leftArea: leftArea, rightArea: rightArea };
        }).catch(function () { return blank; }); // Let fetch fail gracefully; return blank slate.
    };
    /**
     * Restore the widgets of a particular instance tracker.
     *
     * @param tracker - The instance tracker whose widgets will be restored.
     *
     * @param options - The restoration options.
     */
    InstanceRestorer.prototype.restore = function (tracker, options) {
        if (!this._promises) {
            var warning = 'restore() can only be called before `first` has resolved.';
            console.warn(warning);
            return Promise.reject(warning);
        }
        var namespace = tracker.namespace;
        if (this._trackers.has(namespace)) {
            var warning = "A tracker namespaced " + namespace + " was already restored.";
            console.warn(warning);
            return Promise.reject(warning);
        }
        this._trackers.add(namespace);
        var args = options.args, command = options.command, name = options.name, when = options.when;
        var first = this._first;
        var promise = tracker.restore({
            args: args, command: command, name: name,
            registry: this._registry,
            restorer: this,
            state: this._state,
            when: when ? [first].concat(when) : first
        });
        this._promises.push(promise);
        return promise;
    };
    /**
     * Save the layout state for the application.
     */
    InstanceRestorer.prototype.save = function (data) {
        // If there are promises that are unresolved, bail.
        if (this._promises) {
            var warning = 'save() was called prematurely.';
            console.warn(warning);
            return Promise.reject(warning);
        }
        var dehydrated = {};
        var current;
        // Dehydrate main area.
        if (data.currentWidget) {
            current = Private.nameProperty.get(data.currentWidget);
            if (current) {
                dehydrated.current = current;
            }
        }
        // Dehydrate left area.
        dehydrated.left = this._dehydrateSideArea(data.leftArea);
        // Dehydrate right area.
        dehydrated.right = this._dehydrateSideArea(data.rightArea);
        return this._state.save(KEY, dehydrated);
    };
    /**
     * Dehydrate a side area into a serialized description object.
     */
    InstanceRestorer.prototype._dehydrateSideArea = function (area) {
        var dehydrated = { collapsed: area.collapsed };
        if (area.currentWidget) {
            var current = Private.nameProperty.get(area.currentWidget);
            if (current) {
                dehydrated.current = current;
            }
        }
        if (area.widgets) {
            dehydrated.widgets = area.widgets
                .map(function (widget) { return Private.nameProperty.get(widget); })
                .filter(function (name) { return !!name; });
        }
        return dehydrated;
    };
    /**
     * Reydrate a serialized side area description object.
     *
     * #### Notes
     * This function consumes data that can become corrupted, so it uses type
     * coercion to guarantee the dehydrated object is safely processed.
     */
    InstanceRestorer.prototype._rehydrateSideArea = function (area) {
        if (!area) {
            return { collapsed: true, currentWidget: null, widgets: null };
        }
        var internal = this._widgets;
        var collapsed = area.hasOwnProperty('collapsed') ? !!area.collapsed
            : false;
        var currentWidget = area.current && internal.has("" + area.current) ?
            internal.get("" + area.current) : null;
        var widgets = !Array.isArray(area.widgets) ? null
            : area.widgets
                .map(function (name) { return internal.has("" + name) ? internal.get("" + name) : null; })
                .filter(function (widget) { return !!widget; });
        return { collapsed: collapsed, currentWidget: currentWidget, widgets: widgets };
    };
    /**
     * Handle a widget disposal.
     */
    InstanceRestorer.prototype._onWidgetDisposed = function (widget) {
        var name = Private.nameProperty.get(widget);
        this._widgets.delete(name);
    };
    return InstanceRestorer;
}());
exports.InstanceRestorer = InstanceRestorer;
/*
 * A namespace for private data.
 */
var Private;
(function (Private) {
    /**
     * An attached property for a widget's ID in the state database.
     */
    Private.nameProperty = new properties_1.AttachedProperty({
        name: 'name',
        create: function (owner) { return ''; }
    });
})(Private || (Private = {}));
//# sourceMappingURL=instancerestorer.js.map