// Copyright (c) Jupyter Development Team.
// Distributed under the terms of the Modified BSD License.
"use strict";
/**
 * The class name added to all hover boxes.
 */
var HOVERBOX_CLASS = 'jp-HoverBox';
/**
 * The class name added to a hovering node that is scrolled out of view.
 */
var OUTOFVIEW_CLASS = 'jp-mod-outofview';
/**
 * A namespace for `HoverBox` members.
 */
var HoverBox;
(function (HoverBox) {
    /**
     * Set the visible dimensions of a hovering box anchored to a scrollable node.
     *
     * @param options - The hover box geometry calculation options.
     */
    function setGeometry(options) {
        var anchor = options.anchor, anchorPoint = options.anchorPoint, charWidth = options.charWidth, coords = options.coords, cursor = options.cursor, lineHeight = options.lineHeight, node = options.node;
        // Add hover box class if it does not exist.
        node.classList.add(HOVERBOX_CLASS);
        // Clear any previously set max-height.
        node.style.maxHeight = '';
        // Clear any programmatically set margin-top.
        node.style.marginTop = '';
        // Make sure the node is visible.
        node.classList.remove(OUTOFVIEW_CLASS);
        // Always use the original coordinates to calculate box position.
        var style = window.getComputedStyle(node);
        var innerHeight = window.innerHeight;
        var scrollDelta = anchorPoint - anchor.scrollTop;
        var spaceAbove = coords.top + scrollDelta;
        var spaceBelow = innerHeight - coords.bottom - scrollDelta;
        var marginTop = parseInt(style.marginTop, 10) || 0;
        var maxHeight = parseInt(style.maxHeight, 10) || options.maxHeight;
        var minHeight = parseInt(style.minHeight, 10) || options.minHeight;
        var anchorRect = anchor.getBoundingClientRect();
        var top;
        // If the whole box fits below or if there is more space below, then
        // rendering the box below the text being typed is privileged so that
        // the code above is not obscured.
        var renderBelow = spaceBelow >= maxHeight || spaceBelow >= spaceAbove;
        if (renderBelow) {
            maxHeight = Math.min(spaceBelow - marginTop, maxHeight);
        }
        else {
            maxHeight = Math.min(spaceAbove, maxHeight);
            // If the box renders above the text, its top margin is irrelevant.
            node.style.marginTop = '0px';
        }
        node.style.maxHeight = maxHeight + "px";
        // Make sure the box ought to be visible.
        var withinBounds = maxHeight > minHeight &&
            (spaceBelow >= lineHeight || spaceAbove >= anchorRect.top);
        if (!withinBounds) {
            node.classList.add(OUTOFVIEW_CLASS);
            return;
        }
        var borderLeftWidth = style.borderLeftWidth;
        var left = coords.left + (parseInt(borderLeftWidth, 10) || 0);
        var start = cursor.start, end = cursor.end;
        var nodeRect = node.getBoundingClientRect();
        // Position the box vertically.
        top = renderBelow ? innerHeight - spaceBelow : spaceAbove - nodeRect.height;
        node.style.top = Math.floor(top) + "px";
        // Move box to the start of the blob of text in the referent editor.
        left -= charWidth * (end - start);
        node.style.left = Math.ceil(left) + "px";
        node.style.width = 'auto';
        // Expand the menu width by the scrollbar size, if present.
        if (node.scrollHeight >= maxHeight) {
            node.style.width = "" + (2 * node.offsetWidth - node.clientWidth);
            node.scrollTop = 0;
        }
    }
    HoverBox.setGeometry = setGeometry;
})(HoverBox = exports.HoverBox || (exports.HoverBox = {}));
//# sourceMappingURL=hoverbox.js.map