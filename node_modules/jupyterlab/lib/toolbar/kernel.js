// Copyright (c) Jupyter Development Team.
// Distributed under the terms of the Modified BSD License.
"use strict";
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var widgets_1 = require("@phosphor/widgets");
var docregistry_1 = require("../docregistry");
var index_1 = require("./index");
/**
 * The class name added to toolbar interrupt button.
 */
var TOOLBAR_INTERRUPT_CLASS = 'jp-StopIcon';
/**
 * The class name added to toolbar restart button.
 */
var TOOLBAR_RESTART_CLASS = 'jp-RefreshIcon';
/**
 * The class name added to toolbar kernel name text.
 */
var TOOLBAR_KERNEL_CLASS = 'jp-Kernel-toolbarKernelName';
/**
 * The class name added to toolbar kernel indicator icon.
 */
var TOOLBAR_INDICATOR_CLASS = 'jp-Kernel-toolbarKernelIndicator';
/**
 * The class name added to a busy kernel indicator.
 */
var TOOLBAR_BUSY_CLASS = 'jp-mod-busy';
/**
 * Create an interrupt toolbar item.
 */
function createInterruptButton(kernelOwner) {
    return new index_1.ToolbarButton({
        className: TOOLBAR_INTERRUPT_CLASS,
        onClick: function () {
            if (kernelOwner.kernel) {
                kernelOwner.kernel.interrupt();
            }
        },
        tooltip: 'Interrupt the kernel'
    });
}
exports.createInterruptButton = createInterruptButton;
/**
 * Create a restart toolbar item.
 */
function createRestartButton(kernelOwner, host) {
    return new index_1.ToolbarButton({
        className: TOOLBAR_RESTART_CLASS,
        onClick: function () {
            docregistry_1.restartKernel(kernelOwner.kernel, host);
        },
        tooltip: 'Restart the kernel'
    });
}
exports.createRestartButton = createRestartButton;
/**
 * Create a kernel name indicator item.
 *
 * #### Notes
 * It will display the `'display_name`' of the current kernel,
 * or `'No Kernel!'` if there is no kernel.
 * It can handle a change in context or kernel.
 */
function createKernelNameItem(kernelOwner) {
    return new KernelName(kernelOwner);
}
exports.createKernelNameItem = createKernelNameItem;
/**
 * A kernel name widget.
 */
var KernelName = (function (_super) {
    __extends(KernelName, _super);
    /**
     * Construct a new kernel name widget.
     */
    function KernelName(kernelOwner) {
        var _this = _super.call(this) || this;
        _this.addClass(TOOLBAR_KERNEL_CLASS);
        _this._onKernelChanged(kernelOwner, kernelOwner.kernel);
        kernelOwner.kernelChanged.connect(_this._onKernelChanged, _this);
        return _this;
    }
    /**
     * Update the text of the kernel name item.
     */
    KernelName.prototype._onKernelChanged = function (sender, kernel) {
        var _this = this;
        this.node.textContent = 'No Kernel!';
        if (!kernel) {
            return;
        }
        kernel.getSpec().then(function (spec) {
            if (!_this.isDisposed) {
                _this.node.textContent = spec.display_name;
            }
        });
    };
    return KernelName;
}(widgets_1.Widget));
/**
 * Create a kernel status indicator item.
 *
 * #### Notes
 * It show display a busy status if the kernel status is
 * not idle.
 * It will show the current status in the node title.
 * It can handle a change to the context or the kernel.
 */
function createKernelStatusItem(kernelOwner) {
    return new KernelIndicator(kernelOwner);
}
exports.createKernelStatusItem = createKernelStatusItem;
/**
 * A toolbar item that displays kernel status.
 */
var KernelIndicator = (function (_super) {
    __extends(KernelIndicator, _super);
    /**
     * Construct a new kernel status widget.
     */
    function KernelIndicator(kernelOwner) {
        var _this = _super.call(this) || this;
        _this._kernel = null;
        _this.addClass(TOOLBAR_INDICATOR_CLASS);
        _this._onKernelChanged(kernelOwner, kernelOwner.kernel);
        kernelOwner.kernelChanged.connect(_this._onKernelChanged, _this);
        return _this;
    }
    /**
     * Handle a change in kernel.
     */
    KernelIndicator.prototype._onKernelChanged = function (sender, kernel) {
        if (this._kernel) {
            this._kernel.statusChanged.disconnect(this._handleStatus, this);
        }
        this._kernel = kernel;
        if (kernel) {
            this._handleStatus(kernel, kernel.status);
            kernel.statusChanged.connect(this._handleStatus, this);
        }
        else {
            this.node.title = 'No Kernel!';
            this.addClass(TOOLBAR_BUSY_CLASS);
        }
    };
    /**
     * Handle a status on a kernel.
     */
    KernelIndicator.prototype._handleStatus = function (kernel, status) {
        if (this.isDisposed) {
            return;
        }
        this.toggleClass(TOOLBAR_BUSY_CLASS, status !== 'idle');
        var title = 'Kernel ' + status[0].toUpperCase() + status.slice(1);
        this.node.title = title;
    };
    return KernelIndicator;
}(widgets_1.Widget));
//# sourceMappingURL=kernel.js.map